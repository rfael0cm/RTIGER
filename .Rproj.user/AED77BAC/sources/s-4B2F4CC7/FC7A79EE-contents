DataSetImportFromtxt2 = function(
  experimentDesign = NULL,
  path = NULL,
  pattern = NULL,
  observations = NULL,
  GenRanges = NULL,
  bin.length = NULL,
  max.bin = NULL,
  min.bin = NULL,
  min.samples = 1,
  quant = .2,
  min.counts = 10,
  seqlengths = NULL
){

  if(is.null(path) & is.null(experimentDesign) & is.null(observations)){
    stop("No file information found!")
  }

  # Check path and patterns -------------------------------------------------


  if(!is.null(path)){
    if(!dir.exists(path)){
      stop("path to the files does not exist")
    }

    if(!length(list.files(path))){
      stop("No files in path directory")
    }

    if(!is.null(pattern)){
      if(!list.files(path = path, pattern = pattern)){
        stop("Do not exist files with this pattern")
      }
    }

    if(is.null(pattern)) pattern = ".txt"
    files = list.files(path, pattern, full.names = TRUE)
    myCol = data.frame(files = files, name = sapply(files, function(filepath) sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(filepath))))
  }

  # Check expDesign ---------------------------------------------------------

  if(!is.null(experimentDesign)){
    # cat("I am in experimentDesign\n")
    myCol = experimentDesign[, c("files", "name")]



    # Load files, check rows and columns and create GR object -----------------
    # cat(myCol)



    rawGR = sapply(1:nrow(myCol), function(i){
      samp = as.character(myCol$files[i])
      print(paste("Loading file: ", myCol$files[i]))

      f <- read.delim(file =samp, header = FALSE)

      f = checkfileColumns(f)

      myG = GRanges(seqnames =  f$V1,
                    ranges = IRanges(start = f$V2, end = f$V2),
                    P1.Allele = f$V3,
                    P1.Allele.Count = f$V4,
                    P2.Allele = f$V5,
                    P2.Allele.Count = f$V6,
                    seqlengths = seqlengths
      )

      return(myG)
    }) # end sapply rawGR

    names(rawGR) = myCol$name


  }

  if(!is.null(observations)){

    rawGR = sapply(observations, function(obs){
      obs = t(do.call(cbind, obs))

      myG = GRanges(GenRanges,
                    # P1.Allele = NA,
                    P1.Allele.Count = obs[,1],
                    # P2.Allele = f$V5,
                    P2.Allele.Count = obs[,2] - obs[,1]
                    # seqlengths = seqlengths
      )

      return(myG)
    }) # end sapply rawGR




  }



  if(!is.null(bin.length)){
    listGR = lapply(rawGR, function(myG){
      binningFun(myG, bin.length = bin.length)
    })

    total = sapply(listGR, function(x) as.numeric(x$total))
    print(class(total))
    # if(class(total) == "list") total = unlist(total)

    old.bin.length = bin.length
    while(criterion(total, quant, min.counts)){
      bin.length = bin.length + old.bin.length


      cat(paste("New bin length = ", bin.length, "\n"))
      listGR = lapply(listGR, function(myG){
        binningFun2(myG, bin.length = bin.length)
      })

      total = sapply(listGR, function(x) as.numeric(x$total))
      # if(class(total) == "list") total = unlist(total)
    } # while loop

  } # !is.null(bin.length)



  if(!is.null(max.bin) & !is.null(min.bin) ){

    listGR_max = lapply(listGR, function(myG){

      bins <- tileGenome(seqinfo(myG), tilewidth= max.bin,
                         cut.last.tile.in.chrom=TRUE)

      hits = findOverlaps(bins, myG)

      agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                      total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

      bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

      bins$total[countQueryHits(hits) > 0L] = agg$total

      return(bins)
    }) #list_GR with max bin width

    total_max = sapply(listGR_max, function(x) as.numeric(x$total))

    if(criterion(total_max, quant, min.counts)) stop("The maximum bin width is not enough. Increse the bin width.\n\n")

    listGR_min = lapply(listGR, function(myG){

      bins <- tileGenome(seqinfo(myG), tilewidth= min.bin,
                         cut.last.tile.in.chrom=TRUE)

      hits = findOverlaps(bins, myG)

      agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                      total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

      bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

      bins$total[countQueryHits(hits) > 0L] = agg$total

      return(bins)
    })

    total_min = sapply(listGR_min, function(x) as.numeric(x$total))

    repeat{

      middlebin = ceiling((max.bin + min.bin)/2)

      if(middlebin == max.bin) break()

      listGR_mid = lapply(listGR, function(myG){

        bins <- tileGenome(seqinfo(myG), tilewidth= middlebin,
                           cut.last.tile.in.chrom=TRUE)

        hits = findOverlaps(bins, myG)

        agg =  agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                               total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

        bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

        bins$total[countQueryHits(hits) > 0L] = agg$total

        return(bins)
      })

      total_mid = sapply(listGR_mid, function(x) as.numeric(x$total))

      if(criterion(total_mid, quant, min.counts)) {
        min.bin = middlebin

        listGR_min = lapply(listGR, function(myG){

          bins <- tileGenome(seqinfo(myG), tilewidth= min.bin,
                             cut.last.tile.in.chrom=TRUE)

          hits = findOverlaps(bins, myG)

          agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                          total = sum(total, na.rm = T))

          bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

          bins$total[countQueryHits(hits) > 0L] = agg$total

          return(bins)
        })

        total_min = sapply(listGR_min, function(x) as.numeric(x$total))


      } else {
        max.bin = middlebin

        listGR_max = lapply(listGR, function(myG){

          bins <- tileGenome(seqinfo(myG), tilewidth= max.bin,
                             cut.last.tile.in.chrom=TRUE)

          hits = findOverlaps(bins, myG)

          agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                          total = sum(total, na.rm = T))

          bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

          bins$total[countQueryHits(hits) > 0L] = agg$total

          return(bins)
        }) #list_GR with max bin width

        total_max = sapply(listGR_max, function(x) as.numeric(x$total))


      } #end else

    } # end repeat

  }# If is.null max.bin and min.bin


  chrPos = unlist(sapply(listGR, function(myG){
    vals = paste(seqnames(myG[!is.na(myG$total) ]), start(myG[!is.na(myG$total) ]), sep = "_")
    return(vals)
  }) #sapply
  )
  goods = which(table(chrPos) >= min.samples) # Filter positions by the number of samples that have sequences that position

  goodNam = names(goods)

  newGoodGR = lapply(listGR, function(myG){
    m = as.data.frame(myG)
    m$chrPos = paste(m$seqnames, m$start, sep = "_")
    m = m[m$chrPos %in% goodNam, ]
    m = GRanges(m)
    seqlengths(m) = seqlengths(myG)
    m = sort(m)
    return(m)
  })

  obs = lapply(newGoodGR, function(samp){
    chrs = lapply(seqlevels(samp), function(chr){
      myG = samp[seqnames(samp) == chr]
      p = as.matrix(mcols(myG[, c("P1.Allele.Count", "total")]))
      colnames(p) = c("paternal", "total")
      p[p[,"total"] == 0,] = NA

      p = t(p)
      colnames(p) = myG$chrPos

      return(p)
    })
    names(chrs) = seqlevels(samp)

    return(chrs)
  })

  # total = sapply(newGoodGR, function(x) as.numeric(x$total))
  # quantile(total[total > 0], quant, na.rm = TRUE)

  info = create_info(obs)

  filteringThreshold = list(min.counts = min.counts, quantile = quant, min.samples = min.samples)

  myObj <- .RTIGER(RawData = rawGR, FilteredData = list(as.GR = newGoodGR, as.mat = obs), info = info, FilteringThreshold = filteringThreshold, Model =list(), Viterbi = list())
  return(myObj)
}
