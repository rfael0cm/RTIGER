---
title: "RTIGER"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RTIGER}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(RTIGER, quietly = TRUE)
```
# Introduction

Meiotic recombination is an essential mechanism in the sexual reproduction of
diploid eukaryotic organisms that consists of the overcrossing (chiasmata) between
pairs of homologous chromosomes [REF]. This process ensures equitable segregation
of the genomic material in each gamete. Due to this process, new combinations
of alleles are transmitted to new generations allowing genetic variability among
individuals and benefits the adaptation of populations. Recombination occurs in
the so-called meiosis I and is triggered by double strand breaks (DBSs). The DBSs
can be repaired by crossover with the homologous chromosome (CO) or by the
same chromosome (NCO). The CO/NCO ratio is controlled in each chromosome
and taxa and the mechanism by which it is determined the proportion of DSBs is
resolved as CO is unknown [REF].

In plants, the distribution of CO along the chromosome is largely random, with
some locations such as the centromere being disfavored, and some CO hotspots [REF]
. A better understanding of the crossing over process is essential for various
branches of molecular biology such as medicine, agriculture, etc. [REF] The aim
of this package is to offer a possible solution for the genotyping of recombinant
populations, generated from ancestors with known genotype, by sparse sequencing of their genomes.

# Genotyping three sequencing samples from Arabidopsis Thaliana

As an example, we will show how to analyze the genotype of seven different plants of *Arabidopsis Thaliana*. The bam files have been previously processed to extract the SNP information at each position. Our package works with txt files which contain six columns. The first column defines the chromosome, second the position of the SNP third the allele of one of the parents, the read counts that support such allele, the allele of the second parent and the allele that supports these second allele.

```{r quick start, include=TRUE}
path = system.file("extdata",  package = "RTIGER")
files = list.files(path, full.names = TRUE)

file.example = read.delim(files[1], header = FALSE)
head(file.example)
```

## Initialize

In order to initialize our model we need a data frame with minimum two columns. The files columns, which contains the full path to the files of each sample and the name column, which has a shorter name by which we will refer to each sample. In our example, we will use the file name as name of the sample:

```{r loading data, include = TRUE}
expDesign = data.frame(files = files, name = list.files(path))

expDesign
```

This together with the sequence length of each chromosome of our organism is all we need to start the package. Moreover, we will need to decide some thresholds by which the chromosomes will be binned in order to increase the sequencing counts at each position.

```{r initializing mydat, include =TRUE}

data("ATseqlengths")


myDat = DataSetImportFromtxt(experimentDesign = expDesign,
                             bin.length = 100,
                             min.samples = 2,
                             quant = 0.2,
                             min.counts = 5,
                             seqlengths = ATseqlengths[1:4])
```

In our initialization, we have specified that the bins should start with 200 nt and increase if the minimum condition does not hold. The condition we have used is that only 20% (quant) of the observations should have less than 5 (min.counts) counts. Also, each position must be supported by at least 2 samples to be taken in account.
This functions generates an object of class "RTIGER". A quick look into it will give us some information about the sample names, chromosomes and number of observations per chromosome:

```{r look into the data}
myDat
```

## Analize samples

Our threshold previously set, is applied to all the observations as a whole. But does it apply to each individual sample? What is the library size for each sample? 
We can learn a bit more about our samples using a simple function:

The three barplots in red are samples that do not pass the threshold set for all observations. That means that their quantile 20% is lower that 5. This could create problems in further analysis since lower library size will produce higher number of false positives when we want to infer the number of COs.

Since this is an example, we will continue with those samples.

## Fitting the model

The next step is to fit the parameters of our R-TIGER model. An HMM based model specific for gentoyping. For sake of time we will only use 1 iteration, but in practical cases it should run till convergence:

```{r fitting model, warning=FALSE}
myDat = fitModel(myDat, 
                 max.iter = 1, 
                 verbose = TRUE)

myAnalysis = analysis.samples(myDat)

myAnalysis$lib.size

barplot(myAnalysis$lib.size, col = (!myAnalysis$passThresh) +1, las = 2)

```

## Plotting

During the fitting the single observations have been decoded into the 3 possible states: homozygous parent one, homozygous parent two or heterozygous. We can plot the result for chromosome 3 of the sample input_corrected3647_AA_run513_GTAGAGGA_S20_L007

```{r plot simple}
samp = sample(myDat@info$sample_names, 1)
chr = 3

plotGenotype(myDat, samp = samp, chr = chr)

```

## R-Viterbi algorithm

Nevertheless, this is not an optimal result. There are more jumps than expected in one simple chromosome. This is a known problem of this type of data. We have implemented a new version of the viterbi algorithm in which we force to stay in a single state r times before being possible to jump to another state.

```{r rviterbi, warning=FALSE}

rviterbi = R.Viterbi(myDat, rigidity = 100)

plotGenotype(rviterbi, samp = samp, chr = chr)
```

## Number of Chrosover ovents per chromosomome

Our next goal is to study the number of CO events and double CO (dCO). We define the pure dCO those which are heterogeneous and have the same paternal genotype at each end. When this pattern is observerd, it means that there has been a double cross over in a single chromosome.

```{r numbero of CO}

CO.number = calcCOnumber(rviterbi)

library(reshape2)
library(ggplot2)

Co.number.melt = melt(CO.number)

ggplot(Co.number.melt, aes( x = factor(Var1), y = value, fill = factor(Var1))) +
  geom_boxplot() +
  theme(legend.position = "none")+
  xlab("chromosome") +
  ylab("Number of CO")

dco.number = calcDoubleCOnumber(rviterbi)
dco.number.melt = melt(dco.number)

ggplot(dco.number.melt, aes( x = factor(Var1), y = value, fill = factor(Var1))) +
  geom_boxplot() +
  theme(legend.position = "none")+
  xlab("chromosome") +
  ylab("Number of double CO")

```

## CO widths

Another interesting information that we can obtain is the widht of each haplotype:


```{r haplotypes widhts}

CO.widths = haplotypes.width(rviterbi)

CO.widths = data.frame(x = unlist(CO.widths), viterbi = rep("R-Viterbi", length(unlist(CO.widths))))

CO.HMM.widhts = haplotypes.width(myDat)

CO.HMM.widhts = data.frame(x = unlist(CO.HMM.widhts), viterbi = rep("Standard", length(unlist(CO.HMM.widhts))))

comp.Table = rbind(CO.widths, CO.HMM.widhts)

ggplot(comp.Table, aes(x, stat(density), colour = viterbi)) +
  geom_freqpoly(binwidth = 500)

```
As we can observe the standard HMM viterbi algorithm produces more CO and shorter. This is not the expected behaviour 

