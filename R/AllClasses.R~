################################################################
####### RTIGER class
####### Constructor and show methods
################################################################



#' This class is a generic container for RTIGER analysis
#'
#' @slot RawData Raw data
#' @slot FIlteredData List containing the filtered data based on the minimum number of samples supporting the each position and summing over the bin size.
#' @slot Model fitted model to the data
#' @slot info List with information about the samples.
#' @slot Viterbi List of chromosomes with the viterbi path per sample
#' @rdname RTIGERDataSet
#' @export RTIGER

.RTIGER = setClass("RTIGER",
         representation = representation(
           RawData = "list",
           FilteredData = "list",
           FilteringThreshold = "list",
           info = "list",
           Model = "list",
           Viterbi = "list"
         ))

#'
#'This function creates an RTIGERDataSet from a list of txt files with the SNP counts for each sample
#'
#' @param experimentDesign
#' @param path
#' @param pattern
#' @param bin.length
#' @param min.samples
#'
#'

DataSetImportFromtxt = function(
  experimentDesign = NULL,
  path = NULL,
  pattern = NULL,
  bin.length = NULL,
  max.bin = NULL,
  min.bin = NULL,
  min.samples = 1,
  quant = .2,
  min.counts = 10,
  seqlengths = NULL
){
  # CHECK:
  #         - is the path a real path?
  #         - Are there files in the path?
  #         - are there files with the wanted pattern?
  #         - Are all the values positive integers?
  #

  if(is.null(path) & is.null(experimentDesign)){
    stop("No file information found!")
  }

# Check path and patterns -------------------------------------------------


  if(!is.null(path)){
    if(!dir.exists(path)){
      stop("path to the files do not exist")
    }

    if(!length(list.files(path))){
      stop("No files in path directory")
    }

    if(!is.null(pattern)){
      if(!list.files(path = path, pattern = pattern)){
        stop("Do not exist files with this pattern")
      }
    }

    if(is.null(pattern)) pattern = ".txt"
    files = list.files(path, pattern, full.names = TRUE)
    myCol = data.frame(files = files, name = sapply(files, function(filepath) sub(pattern = "(.*)\\..*$", replacement = "\\1", basename(filepath))))
  }

# Check expDesign ---------------------------------------------------------

  if(!is.null(experimentDesign)){
    myCol = experimentDesign[, c("files", "name")]
  }


# Load files, check rows and columns and create GR object -----------------
  # cat(myCol)

  rawGR = list()
  listGR = list()
  for(i in 1:nrow(myCol)){
    samp = as.character(myCol$files[i])
    print(paste("Loading file: ", myCol$files[i]))
    n = as.character(myCol$name[i])

    f <- read.delim(file =samp, header = F)

    if(class(f$V2) != "integer"){
      stop(cat(paste("Second column in file ", samp, " is not an integer.\nGenomic positions must be integers!" )))
    }

    if(class(f$V4) != "integer" | class(f$V6) != "integer"){
      stop(cate(paste("Either one or both of the allele counts in file ", samp, " are not integers.\nAllele counts must be integers!")))
    } # If values are integers

    f <- f[rowSums(f[,c(4,6)]) != 0, ]
    f <- f[!duplicated(f$V2),]

    myG = GRanges(seqnames =  f$V1,
                          ranges = IRanges(start = f$V2, end = f$V2),
                          P1.Allele = f$V3,
                          P1.Allele.Count = f$V4,
                          P2.Allele = f$V5,
                          P2.Allele.Count = f$V6,
                          seqlengths = seqlengths
    )

    listGR[[n]] = myG
    rawGR[[n]] = myG


  } # for i in nrow(mycol)

  criterion = function(x, quant, min.counts){
    crit = quantile(x[x > 0], quant, na.rm = TRUE) < min.counts
    return(crit)
  }
  if(!is.null(bin.length)){
    listGR = lapply(listGR, function(myG){
      bins <- tileGenome(seqinfo(myG), tilewidth= bin.length,
                         cut.last.tile.in.chrom=TRUE)

      hits = findOverlaps(bins, myG)

      agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                      total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

      bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

      bins$total[countQueryHits(hits) > 0L] = agg$total

      # bins = bins[!is.na(bins$total)]

      return(bins)
    })

    total = sapply(listGR, function(x) as.numeric(x$total))

    old.bin.length = bin.length
    while(criterion(total, quant, min.counts)){
      bin.length = bin.length + old.bin.length


      cat(paste("New bin length = ", bin.length, "\n"))
      listGR = lapply(listGR, function(myG){

        bins <- tileGenome(seqinfo(myG), tilewidth= bin.length,
                           cut.last.tile.in.chrom=TRUE)

        hits = findOverlaps(bins, myG)

        agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                        total = sum(total, na.rm = T))

        bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

        bins$total[countQueryHits(hits) > 0L] = agg$total

        return(bins)
      })

      total = sapply(listGR, function(x) as.numeric(x$total))
    } # while loop

  } # !is.null(bin.length)



  if(!is.null(max.bin) & !is.null(min.bin) ){

    listGR_max = lapply(listGR, function(myG){

      bins <- tileGenome(seqinfo(myG), tilewidth= max.bin,
                         cut.last.tile.in.chrom=TRUE)

      hits = findOverlaps(bins, myG)

      agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                      total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

      bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

      bins$total[countQueryHits(hits) > 0L] = agg$total

      return(bins)
    }) #list_GR with max bin width

    total_max = sapply(listGR_max, function(x) as.numeric(x$total))

    if(criterion(total_max, quant, min.counts)) stop("The maximum bin width is not enough. Increse the bin width.\n\n")

    listGR_min = lapply(listGR, function(myG){

      bins <- tileGenome(seqinfo(myG), tilewidth= min.bin,
                         cut.last.tile.in.chrom=TRUE)

      hits = findOverlaps(bins, myG)

      agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                      total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

      bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

      bins$total[countQueryHits(hits) > 0L] = agg$total

      return(bins)
    })

    total_min = sapply(listGR_min, function(x) as.numeric(x$total))

    repeat{

      middlebin = ceiling((max.bin + min.bin)/2)

      if(middlebin == max.bin) break()

      listGR_mid = lapply(listGR, function(myG){

        bins <- tileGenome(seqinfo(myG), tilewidth= middlebin,
                           cut.last.tile.in.chrom=TRUE)

        hits = findOverlaps(bins, myG)

        agg =  agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                               total = sum(P1.Allele.Count + P2.Allele.Count, na.rm = T))

        bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

        bins$total[countQueryHits(hits) > 0L] = agg$total

        return(bins)
      })

      total_mid = sapply(listGR_mid, function(x) as.numeric(x$total))

      if(criterion(total_mid, quant, min.counts)) {
        min.bin = middlebin

        listGR_min = lapply(listGR, function(myG){

          bins <- tileGenome(seqinfo(myG), tilewidth= min.bin,
                             cut.last.tile.in.chrom=TRUE)

          hits = findOverlaps(bins, myG)

          agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                          total = sum(total, na.rm = T))

          bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

          bins$total[countQueryHits(hits) > 0L] = agg$total

          return(bins)
        })

        total_min = sapply(listGR_min, function(x) as.numeric(x$total))


      } else {
        max.bin = middlebin

        listGR_max = lapply(listGR, function(myG){

          bins <- tileGenome(seqinfo(myG), tilewidth= max.bin,
                             cut.last.tile.in.chrom=TRUE)

          hits = findOverlaps(bins, myG)

          agg = aggregate(myG, hits, P1.Allele.Count = sum(P1.Allele.Count, na.rm = T),
                          total = sum(total, na.rm = T))

          bins$P1.Allele.Count[countQueryHits(hits) > 0L] = agg$P1.Allele.Count

          bins$total[countQueryHits(hits) > 0L] = agg$total

          return(bins)
        }) #list_GR with max bin width

        total_max = sapply(listGR_max, function(x) as.numeric(x$total))


      } #end else

    } # end repeat

  }# If is.null max.bin and min.bin


  chrPos = unlist(sapply(listGR, function(myG){
    vals = paste(seqnames(myG[myG$total != 0 ]), start(myG[myG$total != 0 ]), sep = "_")
    return(vals)
  }) #sapply
  )
  goods = which(table(chrPos) >= min.samples) # Filter positions by the numbero of samples that have sequences that position

  goodNam = names(goods)

  newGoodGR = lapply(listGR, function(myG){
    m = as.data.frame(myG)
    m$chrPos = paste(m$seqnames, m$start, sep = "_")
    m = m[m$chrPos %in% goodNam, ]
    m = GRanges(m)
    seqlengths(m) = seqlengths(myG)
    m = sort(m)
    return(m)
  })

  obs = lapply(newGoodGR, function(samp){
    chrs = lapply(seqlevels(samp), function(chr){
      myG = samp[seqnames(samp) == chr]
      p = as.matrix(mcols(myG[, c("P1.Allele.Count", "total")]))
      colnames(p) = c("paternal", "total")
      p[p[,"total"] == 0,] = NA

      p = t(p)
      colnames(p) = myG$chrPos

      return(p)
    })
    names(chrs) = seqlevels(samp)

    return(chrs)
  })

  # total = sapply(newGoodGR, function(x) as.numeric(x$total))
  # quantile(total[total > 0], quant, na.rm = TRUE)

  info = create_info(obs)

  myObj <- .RTIGER(RawData = rawGR, FilteredData = list(as.GR = newGoodGR, as.mat = obs), info = info, FilteringThreshold = list(), Model =list(), Viterbi = list())
  return(myObj)
}

#' Create info list for observations
#'
#' @keywords internal
#' @noRd
#'

create_info <- function(obs){
  info = list()

  info$sample_names = names(obs)
  info$part_names = names(obs[[1]])
  info$marker_names = lapply(obs[[1]], colnames)
  info$sample_nr = length(obs)
  info$part_nr = length(obs[[1]])
  info$part_lengths = sapply(obs[[1]], ncol)
  info$NAs_matrices = lapply(obs, function(x) lapply(x, function(y){
    res = apply(y, 2, function(r) ifelse(is.na(r), NA, 1))
  }))
  return(info)
}

#' Prints description of RTIGER object
#'
#' @keywords internal
#' @noRd
setMethod(f = "show", signature = c("RTIGER"), function(object) {

  scat <- function(fmt, vals=character(), exdent=2, ...)
  {
    vals <- ifelse(nzchar(vals), vals, "''")
    lbls <- paste(S4Vectors:::selectSome(vals), collapse=" ")
    txt <- sprintf(fmt, length(vals), lbls)
    cat(strwrap(txt, exdent=exdent, ...), sep="\n")
  }

  cat("An object of class \"", class(object), "\" \n", sep = "")
  cat(" Number of samples:  ", object@info$sample_nr, "\n", sep = "")
  # cat(" Sample names: ", paste(as.character(object@info$sample_names), collapse = " "), "\n", sep = "")
  scat(" Sample names(%d): %s \n",object@info$sample_names)
  cat(" Number of chromosomes per sample: ", object@info$part_nr, "\n",
      sep = "")
  cat(" Chromosome names: ", paste(as.character(object@info$part_names), collapse = " "), "\n", sep = "")
  cat(" Number of observations per chromosome: ", paste(as.character(object@info$part_lengths), collapse = " "), "\n", sep = "")

})

